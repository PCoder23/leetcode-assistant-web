import { NextRequest, NextResponse } from "next/server";
import { generateObject } from "ai";
import { openai } from "@ai-sdk/openai";
import OpenAI from "openai";
import { z } from "zod";
import { supabaseServer } from "../../../lib/supabase";

const openai_model = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

// Zod schema matches FeedbackJson
const FeedbackSchema = z.object({
  scores: z.object({
    understanding: z.number().int().min(0).max(10),
    approach: z.number().int().min(0).max(10),
    communication: z.number().int().min(0).max(10),
    code: z.number().int().min(0).max(10),
  }),
  summary: z.string(),
  highlights: z.array(z.string()),
  gaps: z.array(z.string()),
  suggestions: z.array(z.string()),
  follow_up_questions: z.array(z.string()),
  complexity: z.object({
    time: z.string(),
    space: z.string(),
  }),
});

// CORS
export async function OPTIONS() {
  return NextResponse.json(
    {},
    {
      status: 200,
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "POST, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type",
      },
    }
  );
}

export async function POST(req: NextRequest) {
  try {
    const form = await req.formData();
    const file = form.get("audio") as File | null;
    const problemJson = form.get("problem") as string | null;
    const code = form.get("code") as string | null;
    const mode = (form.get("mode") as string) || "self_practice";

    if (!file || !problemJson || !code) {
      return NextResponse.json(
        { error: "Missing inputs" },
        { status: 400, headers: { "Access-Control-Allow-Origin": "*" } }
      );
    }

    const problem = JSON.parse(problemJson);

    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // ðŸ”¹ Step 1: Transcription with Whisper
    const transcription = await openai_model.audio.transcriptions.create({
      file: new File([buffer], "rec.wav", { type: "audio/wav" }),
      model: "whisper-1",
      response_format: "text",
    });

    const transcriptText = transcription.trim();
    console.log("Transcription:", transcriptText);

    // ðŸ”¹ Step 2: Generate Feedback with GPT-4o-mini

    const { object: feedbackJson } = await generateObject({
      model: openai("gpt-4o-mini"),
      schema: FeedbackSchema,
      system: `You are a strict but kind coding interview teacher.  
- Always return valid JSON following the schema.  
- Praise strengths, then explain weaknesses.  
- Suggest corrections in a teacher-like way.  
- Provide realistic follow-up questions to test deeper understanding.

**NOTES**
- The transcript is generated by an automatic speech recognition system and may contain errors, so ignore spell checks but do give harsh feedback on grammar and clarity.
- Feedback is to correct the approach of technical content as well as speech and communication.
- The problem description is provided for context; focus your feedback on the candidate's approach, communication, and code.
- Treat this as a real interview, and be strict but fair and constructive in your feedback.
- Summary should be very explanatory and detailed, what was done well, what could be improved, and how both in terms of technical content and communication. What could be done better next time? what should be focused on for improvement? what was missing or glossed over? what was incorrect or misunderstood? what was good and should be kept up? what was great and should be praised? what was average and could be improved? what was poor and should be worked on? give specific examples from the transcript to illustrate your points.
`,
      prompt: `Problem: ${problem.title}\n\n${problem.body}\n\nTranscript:\n${transcriptText}\n\nCode:\n${code}\n\nMode: ${mode}`,
    });

    console.log("Feedback:", feedbackJson);

    // ðŸ”¹ Step 3: Save session to Supabase
    const { data, error } = await supabaseServer
      .from("sessions")
      .insert({
        problem_url: problem.url,
        problem_title: problem.title,
        problem_body: problem.body,
        code_text: code,
        transcript_text: transcriptText,
        duration_seconds: 0,
        mode,
        feedback_json: feedbackJson,
      })
      .select()
      .single();

    if (error) console.error("Supabase error:", error);
    console.log("Supabase data:", data);

    return NextResponse.json(
      { transcript: transcriptText, feedback: feedbackJson, session: data },
      { status: 200, headers: { "Access-Control-Allow-Origin": "*" } }
    );
  } catch (e: any) {
    console.error(e);
    return NextResponse.json(
      { error: "Processing failed" },
      { status: 500, headers: { "Access-Control-Allow-Origin": "*" } }
    );
  }
}
